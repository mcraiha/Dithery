@inherits LayoutComponentBase
@inject IJSRuntime JSRuntime;

<section>
    <form>
        <header>
            <h2>Settings</h2>
        </header>
        <label for="dithermethod">Dither method:</label>
        <select id="dithermethod">
            <option value="all" selected>All</option>
            <option value="Atkinson">Atkinson</option>
            <option value="Burkes">Burkes</option>
            <option value="Fake">Fake / No dither</option>
            <option value="FloydSteinberg">FloydSteinberg</option>
            <option value="JarvisJudiceNinke">JarvisJudiceNinke</option>
            <option value="Sierra">Sierra</option>
            <option value="SierraLite">SierraLite</option>
            <option value="SierraTwoRow">SierraTwoRow</option>
            <option value="Stucki">Stucki</option>
        </select>
        <label for="colorreductionmethod">Color reduction method:</label>
        <select id="colorreductionmethod">
            <option value="Web safe" selected>Web safe (216 colors)</option>
        </select>
        <button type="button" @onclick="Dither">Dither</button>
    </form>
</section>

<section>
    <h3>Original image</h3>
    <br>
    <img id="originalImageAsPng" src="@defaultImageAsBase64String" />
    <br>
    <h3>Dithered image</h3>
    <br>
    <img id="ditheredImageAsPng" src="@ditheredImageAsBase64String" />
</section>

@code {
    private static DitheringBase GetDitherer(string method, Func<object[],object[]> colorfunc) => 
    method switch
    {
        "Atkinson" => new AtkinsonDitheringRGBByte(colorfunc),
        "Burkes" => new BurkesDitheringRGBByte(colorfunc),
        "Fake" => new FakeDitheringRGBByte(colorfunc),
        "FloydSteinberg" => new FloydSteinbergDitheringRGBByte(colorfunc),
        "JarvisJudiceNinke" => new JarvisJudiceNinkeDitheringRGBByte(colorfunc),
        "Sierra" => new SierraDitheringRGBByte(colorfunc),
        "SierraLite" => new SierraLiteDitheringRGBByte(colorfunc),
        "SierraTwoRow" => new SierraTwoRowDitheringRGBByte(colorfunc),
        "Stucki" => new StuckiDitheringRGBByte(colorfunc),
        _ => throw new ArgumentException(message: "invalid dithering", paramName: method),
    };

    private static object[] TrueColorBytesToWebSafeColorBytes(object[] input)
    {
        int arrayLimit = 3;
        object[] returnArray = new object[input.Length];
        for (int i = 0; i < arrayLimit; i++)
        {
            returnArray[i] = (byte)(Math.Round((byte)input[i] / 51.0) * 51);
        }

        for (int i = arrayLimit; i < input.Length; i++)
        {
            returnArray[i] = (byte)input[i];
        }
        
        return returnArray;
    }

    private async Task Dither()
    {
        string pngStringData = await JSRuntime.InvokeAsync<string>("copyImageDataAsPng", "canvasprocessed");
        int base64Index = pngStringData.IndexOf("base64,");
        int base64Length = "base64,".Length;
        byte[] finalPngData = System.Convert.FromBase64String(pngStringData.Remove(0, base64Index + base64Length));
        Image<Rgb24> imageOriginal = Image.Load<Rgb24>(finalPngData);
        
        using (MemoryStream ms = new MemoryStream())
        {
            await imageOriginal.SaveAsPngAsync(ms);
            defaultImageAsBase64String = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
        }

        Image<Rgb24> imageForDithering = imageOriginal.Clone();
        
        int width = imageForDithering.Width;
        int height = imageForDithering.Height;
        byte[,,] returnValue = new byte[width, height, 3];
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                returnValue[x, y, 0] = imageForDithering[x, y].R;
                returnValue[x, y, 1] = imageForDithering[x, y].G;
                returnValue[x, y, 2] = imageForDithering[x, y].B;
            }
        }

        TempByteImageFormat temp = new TempByteImageFormat(returnValue);

        DitheringBase ditherer = GetDitherer("Atkinson", TrueColorBytesToWebSafeColorBytes);
        temp = (TempByteImageFormat)ditherer.DoDithering(temp);
        
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                object[] pixels = temp.GetPixelChannels(x, y);
                imageForDithering[x, y] = new Rgb24((byte)pixels[0], (byte)pixels[1], (byte)pixels[2]);
            }
        }

        using (MemoryStream ms = new MemoryStream())
        {
            await imageForDithering.SaveAsPngAsync(ms);
            ditheredImageAsBase64String = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
        }
    }

    private static readonly string oneByOneWhitePixelBase64DataPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==";

    [Parameter]
    public string defaultImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;

    [Parameter]
    public string ditheredImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;
}