@inherits LayoutComponentBase
@inject IJSRuntime JSRuntime;

<section>
    <EditForm Model="ditheringSettings">
        <header>
            <h2>Settings</h2>
        </header>
        
        <label for="dithermethod">Dither method:</label>
        <InputSelect @bind-Value="ditheringSettings.ditheringMethod">
        @foreach (var value in Enum.GetValues(typeof(DitheringMethod)))
        {
            <option>@value</option>
        }
        </InputSelect>
        
        <label for="colorreductionmethod">Color reduction method:</label>
        <select id="colorreductionmethod">
            <option value="Web safe" selected>Web safe (216 colors)</option>
        </select>
        <button type="button" @onclick="Dither">Dither</button>
    </EditForm>
</section>

<section>
    <header>
        <h3>Original image</h3>
    </header>
    <img id="originalImageAsPng" src="@defaultImageAsBase64String" />
</section>

<section>
    <header>
        <h3>@dithererName</h3>
    </header>
    <img id="ditheredImageAsPng" src="@ditheredImageAsBase64String" />
</section>

@code {
    private static DitheringBase<byte> GetDitherer(DitheringMethod method, DitheringBase<byte>.ColorFunction colorfunc) => 
    method switch
    {
        DitheringMethod.Atkinson => new AtkinsonDitheringRGBByte(colorfunc),
        DitheringMethod.Burkes => new BurkesDitheringRGBByte(colorfunc),
        DitheringMethod.Fake => new FakeDitheringRGBByte(colorfunc),
        DitheringMethod.FloydSteinberg => new FloydSteinbergDitheringRGBByte(colorfunc),
        DitheringMethod.JarvisJudiceNinke => new JarvisJudiceNinkeDitheringRGBByte(colorfunc),
        DitheringMethod.Sierra => new SierraDitheringRGBByte(colorfunc),
        DitheringMethod.SierraLite => new SierraLiteDitheringRGBByte(colorfunc),
        DitheringMethod.SierraTwoRow => new SierraTwoRowDitheringRGBByte(colorfunc),
        DitheringMethod.Stucki => new StuckiDitheringRGBByte(colorfunc),
        _ => throw new ArgumentException(message: "invalid dithering", paramName: method.ToString()),
    };

    private static void TrueColorBytesToWebSafeColorBytes(in byte[] input, ref byte[] output)
    {
        for (int i = 0; i < input.Length; i++)
        {
            output[i] = (byte)(Math.Round(input[i] / 51.0) * 51);
        }
    }

    private static readonly PngEncoder pngEncoder = new PngEncoder() { CompressionLevel = PngCompressionLevel.BestSpeed };

    private async Task Dither()
    {
        Stopwatch stopwatch = null;
        string pngStringData = null;
        if (JSRuntime is Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime webAssemblyJSRuntime)
        {
            stopwatch = Stopwatch.StartNew();
            pngStringData = webAssemblyJSRuntime.InvokeUnmarshalled<string, string>("copyImageDataAsPng", "canvasprocessed");
            stopwatch.Stop();
            Console.WriteLine($"copyImageDataAsPng took {stopwatch.Elapsed}");
        }
        //string pngStringData = await JSRuntime.InvokeAsync<string>("copyImageDataAsPng", "canvasprocessed");
        int base64Index = pngStringData.IndexOf("base64,");
        int base64Length = "base64,".Length;
        stopwatch = Stopwatch.StartNew();
        byte[] finalPngData = System.Convert.FromBase64String(pngStringData.Remove(0, base64Index + base64Length));
        stopwatch.Stop();
        Console.WriteLine($"string to byte[] conversion took {stopwatch.Elapsed}");

        stopwatch = Stopwatch.StartNew();
        Image<Rgb24> imageOriginal = Image.Load<Rgb24>(finalPngData);
        stopwatch.Stop();
        Console.WriteLine($"loading image from Png bytes took {stopwatch.Elapsed}");

        defaultImageAsBase64String = pngStringData;

        stopwatch = Stopwatch.StartNew();
        Image<Rgb24> imageForDithering = imageOriginal.Clone();
        stopwatch.Stop();
        Console.WriteLine($"Cloning an image took {stopwatch.Elapsed}");
        
        stopwatch = Stopwatch.StartNew();
        int width = imageForDithering.Width;
        int height = imageForDithering.Height;
        byte[,,] returnValue = new byte[width, height, 3];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Rgb24 pixel = imageForDithering[x, y];
                returnValue[x, y, 0] = pixel.R;
                returnValue[x, y, 1] = pixel.G;
                returnValue[x, y, 2] = pixel.B;
            }
        }
        stopwatch.Stop();
        Console.WriteLine($"Creating a copy part I for editing took {stopwatch.Elapsed}");

        stopwatch = Stopwatch.StartNew();
        TempByteImageFormat temp = new TempByteImageFormat(returnValue);
        stopwatch.Stop();
        Console.WriteLine($"Creating a copy part II for editing took {stopwatch.Elapsed}");

        stopwatch = Stopwatch.StartNew();
        DitheringBase<byte> ditherer = GetDitherer(ditheringSettings.ditheringMethod, TrueColorBytesToWebSafeColorBytes);
        temp = (TempByteImageFormat)ditherer.DoDithering(temp);
        stopwatch.Stop();
        Console.WriteLine($"Dithering took {stopwatch.Elapsed}");

        dithererName = $"{ditherer.GetMethodName()} dithering";
        
        stopwatch = Stopwatch.StartNew();
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                byte[] pixels = temp.GetPixelChannels(x, y);
                imageForDithering[x, y] = new Rgb24(pixels[0], pixels[1], pixels[2]);
            }
        }
        stopwatch.Stop();
        Console.WriteLine($"Copying dithered took {stopwatch.Elapsed}");

        using (MemoryStream ms = new MemoryStream())
        {
            stopwatch = Stopwatch.StartNew();
            await imageForDithering.SaveAsPngAsync(ms, pngEncoder);
            stopwatch.Stop();
            Console.WriteLine($"writing image to Png memorystream took {stopwatch.Elapsed}");

            stopwatch = Stopwatch.StartNew();
            ditheredImageAsBase64String = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
            stopwatch.Stop();
            Console.WriteLine($"writing string from Png memorystream took {stopwatch.Elapsed}");
        }
    }

    private static readonly string oneByOneWhitePixelBase64DataPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==";

    public enum DitheringMethod
	{
		All,
		Atkinson,
		Burkes,
		Fake,
		FloydSteinberg,
		JarvisJudiceNinke,
		Sierra,
		SierraLite,
		SierraTwoRow,
		Stucki
	}

    class DitheringSettings
    {
        public DitheringMethod ditheringMethod { get; set; } = DitheringMethod.Atkinson;
    }

    DitheringSettings ditheringSettings = new DitheringSettings();

    [Parameter]
    public string defaultImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;

    [Parameter]
    public string ditheredImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;

    private string dithererName { get; set; } = "Dithered image";
}