@inherits LayoutComponentBase
@inject IJSRuntime JSRuntime;

<section>
    <EditForm Model="ditheringSettings">
        <header>
            <h2>Settings</h2>
        </header>
        
        <label for="dithermethod">Dither method:</label>
        <InputSelect @bind-Value="ditheringSettings.ditheringMethod">
        @foreach (var value in Enum.GetValues(typeof(DitheringMethod)))
        {
            <option>@value</option>
        }
        </InputSelect>
        
        <label for="colorreductionmethod">Color reduction method:</label>
        <select id="colorreductionmethod">
            <option value="Web safe" selected>Web safe (216 colors)</option>
        </select>
        <button type="button" @onclick="Dither">Dither</button>
    </EditForm>
</section>

<section>
    <header>
        <h3>Original image</h3>
    </header>
    <img id="originalImageAsPng" src="@defaultImageAsBase64String" />
</section>

<section>
    <header>
        <h3>Dithered image</h3>
    </header>
    <img id="ditheredImageAsPng" src="@ditheredImageAsBase64String" />
</section>

@code {
    private static DitheringBase GetDitherer(DitheringMethod method, Func<object[],object[]> colorfunc) => 
    method switch
    {
        DitheringMethod.Atkinson => new AtkinsonDitheringRGBByte(colorfunc),
        DitheringMethod.Burkes => new BurkesDitheringRGBByte(colorfunc),
        DitheringMethod.Fake => new FakeDitheringRGBByte(colorfunc),
        DitheringMethod.FloydSteinberg => new FloydSteinbergDitheringRGBByte(colorfunc),
        DitheringMethod.JarvisJudiceNinke => new JarvisJudiceNinkeDitheringRGBByte(colorfunc),
        DitheringMethod.Sierra => new SierraDitheringRGBByte(colorfunc),
        DitheringMethod.SierraLite => new SierraLiteDitheringRGBByte(colorfunc),
        DitheringMethod.SierraTwoRow => new SierraTwoRowDitheringRGBByte(colorfunc),
        DitheringMethod.Stucki => new StuckiDitheringRGBByte(colorfunc),
        _ => throw new ArgumentException(message: "invalid dithering", paramName: method.ToString()),
    };

    private static object[] TrueColorBytesToWebSafeColorBytes(object[] input)
    {
        int arrayLimit = 3;
        object[] returnArray = new object[input.Length];
        for (int i = 0; i < arrayLimit; i++)
        {
            returnArray[i] = (byte)(Math.Round((byte)input[i] / 51.0) * 51);
        }

        for (int i = arrayLimit; i < input.Length; i++)
        {
            returnArray[i] = (byte)input[i];
        }
        
        return returnArray;
    }

    private async Task Dither()
    {
        string pngStringData = await JSRuntime.InvokeAsync<string>("copyImageDataAsPng", "canvasprocessed");
        int base64Index = pngStringData.IndexOf("base64,");
        int base64Length = "base64,".Length;
        byte[] finalPngData = System.Convert.FromBase64String(pngStringData.Remove(0, base64Index + base64Length));
        Image<Rgb24> imageOriginal = Image.Load<Rgb24>(finalPngData);
        
        using (MemoryStream ms = new MemoryStream())
        {
            await imageOriginal.SaveAsPngAsync(ms);
            defaultImageAsBase64String = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
        }

        Image<Rgb24> imageForDithering = imageOriginal.Clone();
        
        int width = imageForDithering.Width;
        int height = imageForDithering.Height;
        byte[,,] returnValue = new byte[width, height, 3];
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                returnValue[x, y, 0] = imageForDithering[x, y].R;
                returnValue[x, y, 1] = imageForDithering[x, y].G;
                returnValue[x, y, 2] = imageForDithering[x, y].B;
            }
        }

        TempByteImageFormat temp = new TempByteImageFormat(returnValue);

        DitheringBase ditherer = GetDitherer(ditheringSettings.ditheringMethod, TrueColorBytesToWebSafeColorBytes);
        temp = (TempByteImageFormat)ditherer.DoDithering(temp);
        
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                object[] pixels = temp.GetPixelChannels(x, y);
                imageForDithering[x, y] = new Rgb24((byte)pixels[0], (byte)pixels[1], (byte)pixels[2]);
            }
        }

        using (MemoryStream ms = new MemoryStream())
        {
            await imageForDithering.SaveAsPngAsync(ms);
            ditheredImageAsBase64String = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
        }
    }

    private static readonly string oneByOneWhitePixelBase64DataPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==";

    public enum DitheringMethod
	{
		All,
		Atkinson,
		Burkes,
		Fake,
		FloydSteinberg,
		JarvisJudiceNinke,
		Sierra,
		SierraLite,
		SierraTwoRow,
		Stucki
	}

    class DitheringSettings
    {
        public DitheringMethod ditheringMethod { get; set; } = DitheringMethod.Atkinson;
    }

    DitheringSettings ditheringSettings = new DitheringSettings();

    [Parameter]
    public string defaultImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;

    [Parameter]
    public string ditheredImageAsBase64String { get; set; } = oneByOneWhitePixelBase64DataPng;
}